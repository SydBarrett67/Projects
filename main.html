<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas Grid</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    #gridCanvas {
      display: block;
    }
    .panel-box {
      background: rgba(100,100,100,0.2);
      border: 2px solid white;
      border-radius: 25px;
      padding: 0.3rem;
      color: white;
    }
    .slider {
      width: 100%;
    }
    .scelte {
      width: 100%;
      font-size: 0.7rem;
      background-color: rgba(100,100,100,0.2);
      color: white;
      border-radius: 25px;
      border: 3px solid white;
      transition: all 0.3s;
    }
    .scelte:hover {
      background-color: white;
      color: black;
      box-shadow: 5px 5px 20px black;
    }
    .scelte:active {
      background-color: #a6353b;
      transform: translateY(3px);
    }
  </style>
</head>
<body onload="createGrid()">
  <canvas id="gridCanvas"></canvas>

  <div class="container-fluid position-absolute top-0 start-0 mt-2">
    <div class="row g-2 justify-content-center">
      
      <!-- Panel -->
      <div class="col-12 col-md-3">
        <div class="panel-box text-center">
          <h5>Alive: <b id="counter"></b></h5>
          <h5>Brush size: <b id="brush">1</b></h5>
          <h5>Speed: <b id="time">100</b>ms</h5>
          <h5>Notes: <b id="scale">Major scale</b></h5>
        </div>
      </div>
      
      <!-- Brush size slider -->
      <div class="col-12 col-md-3">
        <div class="panel-box text-center">
          <input type="range" min="1" max="10" value="1" class="slider" id="brushRange">
          <h6>Brush size controller</h6>
        </div>
      </div>
      
      <!-- Speed slider -->
      <div class="col-12 col-md-3">
        <div class="panel-box text-center">
          <input type="range" min="10" max="1000" value="100" class="slider" id="speedRange">
          <h6>Simulation speed controller</h6>
        </div>
      </div>

      <!-- Buttons -->
      <div class="col-12 col-md-3">
        <div class="d-grid gap-2">
          <button class="scelte" onclick="changemode()"><b id="mode">Draw</b></button>
          <button class="scelte" onclick="playAlgorithm()"><b id="playPause">Play</b></button>
          <button class="scelte" onclick="reset()">Clear</button>
          <button class="scelte" onclick="changeNotes()"><b>Notes</b></button>
        </div>
      </div>

    </div>
  </div>
	
	<script>
		const cellSize = 10;
		let brushSize = 1;
		let canvas, ctx;
		let gridWidth, gridHeight;
		let isDrawing = false;
		let cellCounter = 0;
		let grid = [];
		let cells = [];
		let mode;
		let playing=false;
		let playInterval=null;
		let drawColor = "rgb(255,255,255)";
		let bgColor = "rgb(0,0,0)";
		let time = 100;
		let scale = 0;

		var brushSlider = document.getElementById("brushRange");

		brushSlider.oninput = function() {
			brushSize = parseInt(this.value);
			document.getElementById("brush").innerText = brushSize;
		}

		var speedSlider = document.getElementById("speedRange");

		speedSlider.oninput = function() {
			time = parseInt(this.value);
			document.getElementById("time").innerText = time;
		}

		function reset() {
			let toBeKilled = [];

			for (let y = 0; y < gridHeight; y++) {
				for (let x = 0; x < gridWidth; x++) {
					stopToneForCell(cells[y][x]); // stop tones first
					if (grid[y][x] === 1) {
						toBeKilled.push({x: x, y: y}); // mark cells to clear visually
					}
					grid[y][x] = 0;
					cells[y][x] = null;
				}
			}

			cellCounter = 0;
			redrawFromState([], toBeKilled); // pass empty toBeBorn, and the cells to be cleared
		}
				
		const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

		// major scale : [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8, 2]
		// minor scale : [1, 9/8, 6/5, 4/3, 3/2, 8/5, 9/5, 2]
		// [1, 6/5, 3/2, 9/5, 2]
		const tones = [[1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8, 2], [1, 9/8, 6/5, 4/3, 3/2, 8/5, 9/5, 2], [1, 9/8, 6/5, 4/3, 3/2, 8/5, 15/8, 2], [1, 9/8, 6/5, 4/3, 3/2, 5/3, 9/5, 2]];
		const harmonics = [1,1/*, 5/4, 3/2, 15/8*/];
		const real = new Float32Array(harmonics.length);
		const imag = new Float32Array(harmonics.length);
		harmonics.forEach((h, i) => { real[i] = 0; imag[i] = h; });
		const wave = audioCtx.createPeriodicWave(real, imag);

		function startToneForCell(cell, freq = 440, vol = 0.05, duration = 1.5) {
			if (!cell) return;

			// Create oscillator and gain
			const osc = audioCtx.createOscillator();
			const gainNode = audioCtx.createGain();

			osc.setPeriodicWave(wave);
			osc.frequency.value = freq;

			const now = audioCtx.currentTime;
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(vol, now + 0.01); // attack
			gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration); // decay

			osc.connect(gainNode).connect(audioCtx.destination);
			osc.start(now);
			osc.stop(now + duration + 0.05);

			cell.osc = osc;
			cell.gain = gainNode;

			osc.onended = () => {
				try {
					osc.disconnect();
					gainNode.disconnect();
				} catch {}
				cell.osc = null;
				cell.gain = null;
			};
		}

		function stopToneForCell(cell) {
			if (cell?.osc && cell?.gain) {
				const now = audioCtx.currentTime;

				cell.gain.gain.cancelScheduledValues(now);
				cell.gain.gain.setValueAtTime(cell.gain.gain.value, now); // lock current value
				cell.gain.gain.linearRampToValueAtTime(0, now + 0.05);   // 50ms fade-out

				cell.osc.stop(now + 0.06);

				setTimeout(() => {
					try {
						cell.osc.disconnect();
						cell.gain.disconnect();
					} catch {}
					cell.osc = null;
					cell.gain = null;
				}, 100);
			}
		}

		function createGrid() {
			mode = 1;
			canvas = document.getElementById("gridCanvas");
			ctx = canvas.getContext("2d");

			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;

			gridWidth = Math.floor(canvas.width / cellSize);
			gridHeight = Math.floor(canvas.height / cellSize);

			let oldGrid = grid;
			let oldWidth = oldGrid.length > 0 ? oldGrid[0].length : 0;
			let oldHeight = oldGrid.length;

			grid = [];
			for (let y = 0; y < gridHeight; y++) {
				grid[y] = [];
				for (let x = 0; x < gridWidth; x++) {
					grid[y][x] = (y < oldHeight && x < oldWidth) ? oldGrid[y][x] : 0;
				}
			}

			for (let y = 0; y < gridHeight; y++) {
				cells[y] = [];
				for (let x = 0; x < gridWidth; x++) {
					cells[y][x] = null;
				}
			}

			cellCounter = grid.flat().reduce((a, b) => a + b, 0);

			drawGrid();
		}

		function drawGrid() {
			ctx.fillStyle = bgColor;
			for (let y = 0; y < gridHeight; y++) {
				for (let x = 0; x < gridWidth; x++) {
					ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
				}
			}
			

			if (grid.length === 0) {
				for (let y = 0; y < gridHeight; y++) {
					grid[y] = [];
					for (let x = 0; x < gridWidth; x++) {
						grid[y][x] = 0;
					}
				}
			}

			redrawFromState();
		}

		function redrawFromState(toBeBorn = [], toBeKilled = []) {
			// Draw only changed cells
			ctx.fillStyle = drawColor;
			for (let cell of toBeBorn) {
				ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
			}

			ctx.fillStyle = bgColor;
			for (let cell of toBeKilled) {
				ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
			}

			document.getElementById("counter").innerText = cellCounter;
		}

		function drawPattern(e) {
			const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const gridX = Math.floor(mouseX / cellSize);
            const gridY = Math.floor(mouseY / cellSize);

			if (gridX < 0 || gridX >= gridWidth || gridY < 0 || gridY >= gridHeight) return;

			for (let k = 0; k < brushSize; k++) {
				for (let l = 0; l < brushSize; l++) {
					let bx = gridX - Math.floor(brushSize / 2) + k;
					let by = gridY - Math.floor(brushSize / 2) + l;

					if (bx < 0 || bx >= gridWidth || by < 0 || by >= gridHeight) continue;

					if (mode === 1 && grid[by][bx] === 0) { // Draw
						grid[by][bx] = 1;
						cellCounter++;
					} 
					else if (mode === 0 && grid[by][bx] === 1) { // Erase
						grid[by][bx] = 0;
						cellCounter--;
					}

					ctx.fillStyle = grid[by][bx] ? drawColor : bgColor;
					ctx.fillRect(bx * cellSize, by * cellSize, cellSize, cellSize);
				}
			}

			document.getElementById("counter").innerText = cellCounter;
		}

        function getPointerPosition(e) {
            let clientX, clientY;

            if (e.touches) { // Touch event
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else { // Mouse event
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return { clientX, clientY };
        }

		function changeDrawingMode() {
			mode = (mode === 1) ? 0 : 1;
			document.getElementById("mode").innerText = mode === 1 ? "Draw" : "Erase";
		}

		function stop() {
			clearTimeout(playInterval)
		}

		function changeNotes() {
			switch (scale) {
				case 0:
					document.getElementById("scale").innerText = "Minor scale";
					scale++;
					break;
				case 1:
					document.getElementById("scale").innerText = "Armonic minor scale";
					scale++;
					break;
				case 2:
					document.getElementById("scale").innerText = "Dorian scale";
					scale++;
					break;
				case 3:
					document.getElementById("scale").innerText = "Major scale";
					scale=0;
					break;
			}
		}

		function playAlgorithm() {
			document.getElementById("playPause").innerText = playing ? "Stop" : "Play";
			if (playing) {
				stop();
				playing = false;
				return;
			}
			playing = true;

			function step() {
				let toBeBorn = [];
				let toBeKilled = [];
				for (let y = 0; y < gridHeight; y++) {
					for (let x = 0; x < gridWidth; x++) {
						let alive = 0;

						for (let dy = -1; dy <= 1; dy++) {
							for (let dx = -1; dx <= 1; dx++) {
								if (dx === 0 && dy === 0) continue;
								let ny = y + dy, nx = x + dx;
								if (ny >= 0 && ny < gridHeight && nx >= 0 && nx < gridWidth) {
									if (grid[ny][nx]) alive++;
								}
							}
						}

						if (grid[y][x] && (alive < 2 || alive > 3)) {
							toBeKilled.push({ x, y });
						}
						if (!grid[y][x] && alive === 3) {
							toBeBorn.push({ x, y });
						}
					}
				}

				for (let cell of toBeBorn) {
					grid[cell.y][cell.x] = 1;
					cells[cell.y][cell.x] = ({
						x: cell.x,
						y: cell.y,
						alpha: 1,
						e: grid[cell.y][cell.x]
					})
					cellCounter++;
					startToneForCell(cells[cell.y][cell.x],(220*Math.floor((cell.y+cell.x)/50))*tones[scale][Math.floor(Math.random()*tones.length)],0.005);
				}
				for (let cell of toBeKilled) {
					grid[cell.y][cell.x] = 0;

					let deadCell = cells[cell.y][cell.x]; // keep reference
					stopToneForCell(deadCell);

					cells[cell.y][cell.x] = null;
					cellCounter--;
				}

				/*cells.forEach(() => {

				})*/

				redrawFromState(toBeBorn, toBeKilled);

				if (toBeBorn.length === 0 && toBeKilled.length === 0) {
					playing = false;
					return;
				}

				playInterval = setTimeout(() => requestAnimationFrame(step), time);
			}

			requestAnimationFrame(step);
		}

		
		window.addEventListener("mousedown", (e) => {
			if (e.target === canvas) drawPattern(e);
			isDrawing = true;
		});
		window.addEventListener("mouseup", (e) => {
			isDrawing = false;
		});
		window.addEventListener("mousemove", (e) => {
			if (isDrawing && e.target === canvas) drawPattern(e);
		});
        //touch
        window.addEventListener("touchstart", (e) => {
	        if (e.touches.length === 1 && e.target === canvas) {
	            e.preventDefault();
	            drawPattern(e.touches[0]);
				isDrawing = true;
	        } else {
	            
	            isDrawing = false;
	        }
        }, { passive: false });

        window.addEventListener("touchmove", (e) => {
	        if (e.touches.length === 1 && isDrawing && e.target === canvas) {
	            e.preventDefault();
	            drawPattern(e.touches[0]);
	        }
        }, { passive: false });

	    window.addEventListener("touchend", (e) => {
	        if (e.touches.length === 0) {
	            isDrawing = false;
	        }
        });
		window.addEventListener("resize", createGrid);
	</script>
</body>
</html>


